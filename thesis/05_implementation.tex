\section{Implementation}

Considering object-oriented programming the \emph{Lare} object builds the fundament of a \lare{} backend.
It is a singleton in the request scope.
When receiving a request the server creates it and analyzes the current \http{} header whether a namespace is set or not.
\\
The \lare{} object contains all necessary data and functions.


\subsection{\phpLare{}}
\phpLare{} is a general \lare{} backend to be used in PHP.
It builds the base of every other \lare{} module in PHP, especially for template engines.
\\
As defined before the \lare{} object is implemented as a request-scoped singleton.
This object gets created by the get\_instance() method.
To prevent multiple objects of this class the \_\_clone() and  \_\_construct() methods are replaced by empty functions.
\\
Automatically one object gets instantiated after the definition of this class.


\subsubsection{API}

\large{\textbf{\textit{Lare::is\_enabled()}}}
\\
Returns true if the current request is a Lare request, otherwise false.
\\
\\
\\
\large{\textit{\textbf{Lare::set\_current\_namespace(\$namespace)}}}
\\
\\
\begin{tabular}{|p{4cm}|p{9cm}|}
    \hline
    \textbf{name} & \textbf{description} \\
    \hline
    \$namespace & specifies the namespace which should be set as the current namespace. \\
    \hline
\end{tabular}
\\
\\
Sets the namespace of the current page.
\\
\\
\\
\large{\textbf{\textit{Lare::get\_current\_namespace()}}
\\
Returns the namespace of the current request.
\\
\\
\\
\large{\textbf{\textit{Lare::get\_matching\_count(\$extension\_namespace=None)}}}
\\
\begin{tabular}{|p{4cm}|p{8cm}|}
    \hline
    \textbf{name} & \textbf{description} \\
    \hline
    \$extension\_namespace & (optional) specifies the namespace which should be matched. If not set the current namespace of the Lare object will be used instead. \\
    \hline
\end{tabular}
\\
\\
Returns how many parts of the \$extension\_namespace and the previous namespace (from outer to inner) are matching, before the first mismatch occurs.
\\
\\
\\
\large{\textbf{\textit{Lare::matches(\$extension\_namespace=None)}}}}
\\
\begin{tabular}{|p{5cm}|p{8cm}|}
    \hline
    \textbf{name} & \textbf{description} \\
    \hline
    \$extension\_namespace & (optional) specifies the namespace which should be matched. If not set the current namespace of the Lare object will be used instead. \\
    \hline
\end{tabular}
\\
\\
Returns true if the extension\_namespace matches the previous namespace (on as many layers as extension\_namespace has), otherwise false.
\\
\\
\\
\large{\textbf{\textit{Lare::get\_instance()}}}
\\
Returns the \lare{} singleton and creates it if not instantiated before.

\subsection{\twigLare{}}
Twig-Lare brings Lare functionality to the template engine Twig\footnote{http://twig.sensiolabs.org/}.
Twig is used by Symfony, a framework which is used in e.g. Drupal 8, eZPublish, phpBB and Sylius.
\\
Twig-Lare is implemented as a Twig extension.
It consists of a TwigTokenParser and the global variable lare\_current\_namespace.
The TwigTokenParser
\\
Twig\_Lare\_TokenParser\_LareExtends is the heart of the extension.
It provides the possibility to use the tag \{\% lare\_extends \%\} in the way the default twig tag \{\% extends \%\} tag is used.
Additionally it prevents multiple extend tags.
Furthermore it is ensured that it is not called inside a block tag, like seen in the default twig tag.

\begin{minipage}[c]{0.95\linewidth}
\begin{lstlisting}[caption=Example Lare Template, label=example_lare_template]
{% lare_extends "::base.twig" "Lare.Namespace" "::lare.twig" %}
{% block page %}
  <div id="page">
    ...
  </div>
{% endblock page %}
{% block lare_namespace %}
  {{ current_lare_namespace }}
{% endblock lare_namespace %}
\end{lstlisting}
\end{minipage}
\\
Listing \ref{example_lare_template} shows the usage of this tag.
Using Symfony \enquote{::} is a shortcut for the default template directory.
When the current namespace is not inside \emph{Lare.Namespace} it extends to the base.twig template, because the second namespace does not match then.
When the current namespace is \emph{Lare.Namespace} lare.twig will get extended.
\\
As the namespace matching occurs on the second level in this example, the overridden block should be the according one.
For the naming in this thesis the \emph{page} block should be provided.
Inside this block a <div> container with the according ID has to be placed.

\subsubsection{API}

\large{\textbf{\textit{\{\% lare\_extends \$default\_template \$lare\_namespace \$lare\_template \%\}}}}
\\
\begin{tabular}{|p{4cm}|p{8cm}|}
    \hline
    \textbf{name} & \textbf{description} \\
    \hline
    \$default\_template & specifies which template should be extended in case of a non matching namespace. \\
    \hline
    \$lare\_namespace & (optional) specifies the namespace which is tested against to decide whether the \$default\_template or the \$lare\_template should be extended. If not set, \$default\_template will be extended. \\
    \hline
    \$lare\_template & (optional, default='::\_\_lare.html') specifies which template should be extended in case of a namespace match. \\
    \hline
\end{tabular}

Extends the \$default\_template if \$lare\_namespace is not matching, extends \$lare\_template otherwise.


\subsection{\djangoLare{}}

\djangoLare{} was the first backend of \lare{}.
It was introduced as a single object containing logic and template tools.
After implementing \phpLare{} we decided to change the structure of the django backend towards the new segmentation.
\\
Similar to the combination of \phpLare{} and \twigLare{}, \djangoLare{} consists of a Lare object as in the PHP backend and implements the same templating tools as the Twig extension.
Still as one package it is available via \emph{pip install django-lare} command.


\subsubsection{API}
The \textbf{lare\_extends} tag should be used in the django templating engine.

\newpage{}
\noindent{}\large{\textbf{\textit{\{\% lare\_extends default\_template lare\_namespace lare\_template \%\}}}}
\\
\\
\begin{tabular}{|p{4cm}|p{9cm}|}
    \hline
    \textbf{name} & \textbf{description} \\
    \hline
    default\_template & specifies which template should be extended in case of a non matching namespace. \\
    \hline
    lare\_namespace & (optional) specifies the namespace which is tested against to decide whether the default\_template or the lare\_template should be extended. If not set, default\_template will be extended. \\
    \hline
    lare\_template & (optional, default='\_\_lare.html') specifies which template should be extended in case of a namespace match. \\
    \hline
\end{tabular}
\\
\\
\\
Extends the default\_template if lare\_namespace is not matching, extends lare\_template otherwise.
\\
\\
\\
\\
In the following API documentation of the \textbf{\lare{}} object will \textbf{lare} represent the singleton instance.
\\
\\
\\
\large{\textbf{\textit{lare.is\_enabled()}}}
\\
Returns true if the current request is a Lare request, otherwise false.
\\
\\
\\
\large{\textit{\textbf{lare.set\_current\_namespace(namespace)}}}
\\
\\
\begin{tabular}{|p{4cm}|p{9cm}|}
    \hline
    \textbf{name} & \textbf{description} \\
    \hline
    namespace & specifies the namespace which should be set as the current namespace. \\
    \hline
\end{tabular}
\\
\\
Sets the namespace of the current page.
\\
\\
\\
\large{\textbf{\textit{lare.get\_current\_namespace()}}
\\
Returns the namespace of the current request.
\\
\\
\\
\large{\textbf{\textit{lare.get\_matching\_count(extension\_namespace=None)}}}
\\
\begin{tabular}{|p{4cm}|p{8cm}|}
    \hline
    \textbf{name} & \textbf{description} \\
    \hline
    extension\_namespace & (optional) specifies the namespace which should be matched. If not set the current namespace of the Lare object will be used instead. \\
    \hline
\end{tabular}
\\
\\
Returns how many parts of the extension\_namespace and the previous namespace (from outer to inner) are matching, before the first mismatch occurs.
\\
\\
\\
\large{\textbf{\textit{lare.matches(extension\_namespace=None)}}}}
\\
\begin{tabular}{|p{4cm}|p{8cm}|}
    \hline
    \textbf{name} & \textbf{description} \\
    \hline
    extension\_namespace & (optional) specifies the namespace which should be matched. If not set the current namespace of the Lare object will be used instead. \\
    \hline
\end{tabular}
\\
\\
Returns true if the extension\_namespace matches the previous namespace (on as many layers as extension\_namespace has), otherwise false.
\\
\\
\\
\large{\textbf{\textit{lare.get\_instance()}}}
\\
Returns the \lare{} singleton and creates it if not instantiated before.
\\
\\
\\
After modifications and restructuring of \djangoLare{} the API is similar to the API of \phpLare{}.


\subsection{\lareJS{}}
\lareJS{}, as successor of jquery-pjaxr, is the JavaScript frontend engine for \lare{}, using AJAX to communicate with the server.
It was first built as an extended version of jquery-pjax, allowing to replace multiple containers with one request, instead of only one.
Other than in jquery-pjax it is not needed to define which containers should be replace in the frontend.
It is the job of the backend to define which elements should change, as the frontend does an ID based matching.
\lareJS{} additionally provides the functionality to extend the HTTP header by the current \lare{} namespace.
\\
After the script is loaded it automatically tests if the History API is available or not.
If the requirements are fulfilled it gets initialized.
\\
As described in \ref{lare_frontend} a \lare{} frontend has to hijack page changes.
\lareJS{}, implemented as a jQuery\footnote{\url{https://jquery.com}} plugin realizes this by just one function call, e.g. \$(document).lare('a');.
jQuery plugins normally have a syntax like \$('a').lare();.
But semantically \lareJS{} sets the focus on the engine itself, instead of the items.
Anyway the event listeners will be set by using this method.
\\
Besides the \lare{} functionality \lareJS{} provides utilities for JavaScript including helping functions like e.g. \$(document).lareAlways(function(e) { ... });.
This runs function(e) {} every time a lare request is finished successfully or a history step is made.
This makes it possible to imitate \$(document).ready(function(e) { ... }); provided by jQuery, to hook functions to the document ready event.